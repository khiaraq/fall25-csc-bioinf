import sys
from typing import Dict, List

def read_fasta(path: str) -> List[str]:
    '''reads one fasta file'''
    seqs: List[str] = []
    cur: List[str] = []

    try:
        fh = open(path)
    except:
        return seqs

    for line in fh:
        line = line.strip()
        if not line:
            continue
        if line[0] == '>':
            if cur:
                seqs.append("".join(cur).upper())
                cur = [] # reset
        else:
            cur.append(line)

    fh.close()

    if cur:
        seqs.append("".join(cur).upper())

    return seqs

def join2(a: str, b: str) -> str:
    ''' makes sure two parts of a file path join together properly'''
    if a.endswith("/"):
        return a + b
    else:
        return a + "/" + b

def read_all_fastas(dirpath: str) -> List[str]:
    ''' reads all fasta files using helper functions read_fasta and join2'''
    seqs: List[str] = []

    for name in ["short_1.fasta", "short_2.fasta", "long.fasta"]:
        seqs.extend(read_fasta(join2(dirpath, name)))

    return seqs

# dictionary mapping each DNA base to its complement (unknown "N" maps to itself)
_RC: Dict[str, str] = {"A": "T", "C": "G", "G": "C", "T": "A", "N": "N"}

def revcomp(s: str) -> str:
    ''' reverses DNA string and appends complement'''
    out: List[str] = []

    for ch in reversed(s):
        out.append(_RC.get(ch, "N"))

    return "".join(out)

# De Bruijn Graph 
class DBG:

    def __init__(self, k: int):
        self.k: int = k #k-mer length
        self.child: Dict[str, str] = {} # next node
        self.parent: Dict[str, str] = {} # previous node
        self.used: Dict[str, bool] = {} # if node has been visited

    def add_edge(self, a: str, b: str):
        '''adds directed edge between two k-mers, stores one child per node (last edge), nodes unused so can be traversed later'''
        self.child[a] = b
        self.parent[b] = a
        self.used[a] = False
        self.used[b] = False

    def build(self, reads: List[str]):
        ''' builds graph'''
        k = self.k

        for r in reads:
            if len(r) < k + 1: # skip if too short because need at least k+1 to form edge
                continue

            for s in (r, revcomp(r)): # build graph from reads and revcomp
                for i in range(len(s) - k):
                    a = s[i:i+k] #k-mer                     # !!
                    b = s[i+1:i+1+k] #next k-mer
                    self.add_edge(a, b)

    def longest_path(self) -> List[str]:
        ''' tries all paths starting from unvisited nodes and returns longest'''
        best: List[str] = []

        for v in list(self.child.keys()): # check all the nodes
            if self.used.get(v, False): # skip if node is already used
                continue
            path: List[str] = []
            cur = v

            while cur in self.child and not self.used.get(cur, False):
                path.append(cur) # add node to longest path
                self.used[cur] = True # mark node as vistited
                cur = self.child[cur] # move to child

            if cur and not self.used.get(cur, False):
                path.append(cur) # add the last node 
                self.used[cur] = True

            if len(path) > len(best): # keep the longest path
                best = path

        return best

    def path_to_contig(self, path: List[str]) -> str:
        ''' converts overlapping k-mers into a DNA sequence'''
        if not path:
            return ""

        contig = path[0]

        for s in path[1:]:
            contig += s[-1] # add the last character of each k-mer

        return contig

    def longest_contig(self) -> str:
        '''finds the longest path/list of k-mers and converts into a contig string'''
        path = self.longest_path()

        if not path:
            return ""

        return self.path_to_contig(path)

def main():
    if len(sys.argv) != 2:
        print("Usage: main.codon <dataset_dir>")
        sys.exit(2)

    dataset = sys.argv[1]
    reads = read_all_fastas(dataset)
    dbg = DBG(25) # create a graph with k=25
    dbg.build(reads) # build the graph using reads

    out_path = join2(dataset, "contig.fasta")
    fw = open(out_path, "w") # output FASTA file in dataset folder

    i = 0
    while i < 20: # try to extract up to 20 contigs but stop early if no contig found
        contig = dbg.longest_contig()

        if not contig:
            break

        print(i, len(contig)) # print the contig length to stdout
        fw.write(f">contig_{i}\n") # write FASTA header to FASTA file
        fw.write(contig + "\n") # write contig sequence to FASTA file
        i += 1

    fw.close()

if __name__ == "__main__":
    main()
